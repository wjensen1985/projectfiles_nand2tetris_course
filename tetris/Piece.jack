/** Tetris Piece class */
class Piece {
    field int type;
    field int rowPos;
    field int colPos;
    field int rotationIndex;
    field Matrix boundingBox;
    field int boundingBoxSize;
    // need positions/points field to represent in grid space
    // pivot point?
    // types are I, O, T, S, Z, J, L -> map to ints?

    constructor Piece new(int initType, int x, int y){
        let type = initType;
        let rowPos = x;
        let colPos = y;
        let rotationIndex = 0;

        // let boundingBox = Matrix.new(4, 4, 0);
        // let boundingBoxSize = 4;
        // do boundingBox.set_point(1,2,1);
        // do boundingBox.set_point(2,2,1);
        // do boundingBox.set_point(3,2,1);
        // do boundingBox.set_point(4,2,1);
        // do boundingBox.set_all(1);

        // Types: 0: "I", 1: "O", 2: "Z", 3: "S", 4: "T", 5: "J", 6: "L"

        // "I"
        if ((initType = 0)){
            let boundingBox = Matrix.new(4, 4, 0);
            let boundingBoxSize = 4;
            do boundingBox.set_point(2,1,1);
            do boundingBox.set_point(2,2,1);
            do boundingBox.set_point(2,3,1);
            do boundingBox.set_point(2,4,1);
        }

        // "O"
        if ((initType = 1)){
            let boundingBox = Matrix.new(4, 4, 0);
            let boundingBoxSize = 4;
            do boundingBox.set_point(1,2,1);
            do boundingBox.set_point(1,3,1);
            do boundingBox.set_point(2,2,1);
            do boundingBox.set_point(2,3,1);
        }

        // "Z"
        if ((initType = 2)){
            let boundingBox = Matrix.new(3, 3, 0);
            let boundingBoxSize = 3;
            do boundingBox.set_point(1,1,1);
            do boundingBox.set_point(1,2,1);
            do boundingBox.set_point(2,2,1);
            do boundingBox.set_point(2,3,1);
        }

        // "S"
        if ((initType = 3)){
            let boundingBox = Matrix.new(3, 3, 0);
            let boundingBoxSize = 3;
            do boundingBox.set_point(2,1,1);
            do boundingBox.set_point(2,2,1);
            do boundingBox.set_point(1,2,1);
            do boundingBox.set_point(1,3,1);
        }

        // "T"
        if ((initType = 4)){
            let boundingBox = Matrix.new(3, 3, 0);
            let boundingBoxSize = 3;
            do boundingBox.set_point(2,1,1);
            do boundingBox.set_point(2,2,1);
            do boundingBox.set_point(2,3,1);
            do boundingBox.set_point(1,2,1);
        }
 
        // "J"
        if ((initType = 5)){
            let boundingBox = Matrix.new(3, 3, 0);
            let boundingBoxSize = 3;
            do boundingBox.set_point(1,1,1);
            do boundingBox.set_point(2,1,1);
            do boundingBox.set_point(2,2,1);
            do boundingBox.set_point(2,3,1);
        }

        // "L"
        if ((initType = 6)){
            let boundingBox = Matrix.new(3, 3, 0);
            let boundingBoxSize = 3;
            do boundingBox.set_point(2,1,1);
            do boundingBox.set_point(2,2,1);
            do boundingBox.set_point(2,3,1);
            do boundingBox.set_point(1,3,1);
        }


        return this;
    }

    method int get_bb_size(){
        return boundingBoxSize;
    }

    method Array calcGridCoords(){
        var Array ret;
        var int i, bbRow, bbCol, tmp;
        let i = 0;
        // let ret = Array.new((4*3)); --> 4 blocks for each piece so 4*(r,c,val)
        let ret = Array.new(12);


        let bbRow = 1;
        // do Output.printInt(bbRow);
        // do Output.printInt(boundingBoxSize);
        while (bbRow < (boundingBoxSize+1)) {
            let bbCol = 1;
            while (bbCol < (boundingBoxSize+1)){
                let tmp = boundingBox.get(bbRow, bbCol);
                // do Output.printInt(tmp);
                if (tmp = 1){
                    let ret[i] = rowPos + bbRow - 1;
                    let ret[i+1] = colPos + bbCol - 1;
                    let ret[i+2] = tmp;
                    let i = i + 3;
                }

                let bbCol = bbCol + 1;
            }
            let bbRow = bbRow + 1;
        }

        // one pad in case issue:
        while (i < 12) {
            do Output.printString("calcGridCoords Error - alksdjf;lkajsdl;kfjl;aksdjfl;kjaslk;djf;lkjd");
            let ret[i] = 1;
            let ret[i+1] = 1;
            let ret[i+2] = 1;
            let i = i + 3;
        }

        return ret;
    }

    method int getRow(){
        return rowPos;
    }

    method int getCol(){
        return colPos;
    }

    method int getType(){
        return type;
    }

    method void setRow(int newRowPos){
        let rowPos = newRowPos;
        return;
    }   

    method void setCol(int newColPos){
        let colPos = newColPos;
        return;
    }   

    method void tryMove(Grid board, int dc, int dr){
        // dc is change to column position (left/right)
        // dr is change to row position (up/down)
        
        var boolean canBeMoved;
        let canBeMoved = canMove(board, dc, dr);

        if (canBeMoved) {
            let rowPos = rowPos + dr;
            let colPos = colPos + dc;
        }

        return;
    }

    method boolean canMove(Grid board, int dc, int dr){
        var boolean ret;

        let ret = canPlaceWith(board, boundingBox, rowPos, colPos, dr, dc);
        
        return ret;
    }

    method Matrix rotateCW(Matrix src, int N){
        var Matrix dst;
        var int r, c, v;
        let dst = Matrix.new(N, N, 0);

        let r = 1;
        while (r < (N+1)) {
            let c = 1;
            while (c < (N+1)) {
                let v = src.get((N-c+1), r);
                if (v = 1){
                    do dst.set_point(r,c,1);
                }
                let c = c + 1;
            }
            let r = r + 1;
        }

        return dst;
    }

    method Matrix rotateCCW(Matrix src, int N){
        var Matrix dst;
        var int r, c, v;
        let dst = Matrix.new(N, N, 0);

        let r = 1;
        while (r < (N+1)) {
            let c = 1;
            while (c < (N+1)) {
                let v = src.get(c, (N-r+1));
                if (v = 1){
                    do dst.set_point(r,c,1);
                }
                let c = c + 1;
            }
            let r = r + 1;
        }

        return dst;
    }

    method boolean canPlaceWith(Grid board, Matrix shape, int baseRow, int baseCol, int dy, int dx){
        var int N, r, c, y, x, rows, cols, v;

        let N = boundingBoxSize;
        let rows = board.getRows();
        let cols = board.getCols();

        let r = 1;
        while (r < (N+1)){
            let c = 1;
            while (c < (N+1)){
                let v = shape.get(r, c);
                if (v = 1){
                    let y = baseRow + dy + r - 1;
                    let x = baseCol + dx + c - 1;
                
                    if ((x<1) | (x > cols) | (y<1) | (y > rows)){
                        // OOB
                        return false;
                    }

                    if ( ((board.getPoint(y, x)) = 1) ){
                        // point already occupied
                        return false;
                    }
                }
                let c = c + 1;
            }
            let r = r + 1;
        }

        return true;
    }

    method boolean tryRotateCW(Grid board){
        var Matrix rot;
        var int i, dx, dy, rotLimit;
        var boolean canPlace, isIpiece;
        
        let rot = rotateCW(boundingBox, boundingBoxSize);
        if (type = 0){
            let isIpiece = true; 
            let rotLimit = 7;
        }else{
            let isIpiece = false; 
            let rotLimit = 5;
        }

        // wall kicks
        let i = 0;
        while (i < rotLimit){
            if (i = 0) {
                let dx = 0;
                let dy = 0;
            }
            if (i = 1) {
                let dx = 1;
                let dy = 0;
            }
            if (i = 2) {
                let dx = -1;
                let dy = 0;
            }
            // I-specific rotations
            if ((i = 3) & isIpiece) {
                let dx = 2;
                let dy = 0;
            }
            if ((i = 4) & isIpiece) {
                let dx = -2;
                let dy = 0;
            }
            // back to all
            if ( ((i=5) & isIpiece) | ((i=3) & ~(isIpiece)) ){
                let dx = 0;
                let dy = 1;
            }
            if ( ((i=6) & isIpiece) | ((i=4) & ~(isIpiece)) ){
                let dx = 0;
                let dy = -1;
            }



            let canPlace = canPlaceWith(board, rot, rowPos, colPos, dy, dx); 
            if (canPlace) {
                do boundingBox.dispose();
                let boundingBox = rot;
                let colPos = colPos + dx;
                let rowPos = rowPos + dy;
                return true;
            }
            let i = i + 1;
        }

        do rot.dispose();
        return false;
    }
   
    method boolean tryRotateCCW(Grid board){
        var Matrix rot;
        var int i, dx, dy, rotLimit;
        var boolean canPlace, isIpiece;
        
        let rot = rotateCCW(boundingBox, boundingBoxSize);
        if (type = 0){
            let isIpiece = true; 
            let rotLimit = 7;
        }else{
            let isIpiece = false; 
            let rotLimit = 5;
        }

        // wall kicks
        let i = 0;
        while (i < rotLimit){
            if (i = 0) {
                let dx = 0;
                let dy = 0;
            }
            if (i = 1) {
                let dx = 1;
                let dy = 0;
            }
            if (i = 2) {
                let dx = -1;
                let dy = 0;
            }
            // I-specific rotations
            if ((i = 3) & isIpiece) {
                let dx = 2;
                let dy = 0;
            }
            if ((i = 4) & isIpiece) {
                let dx = -2;
                let dy = 0;
            }
            // back to all
            if ( ((i=5) & isIpiece) | ((i=3) & ~(isIpiece)) ){
                let dx = 0;
                let dy = 1;
            }
            if ( ((i=6) & isIpiece) | ((i=4) & ~(isIpiece)) ){
                let dx = 0;
                let dy = -1;
            }
            // // I-specific rotations
            // if ((i = 7) & isIpiece) {
            //     let dx = 0;
            //     let dy = 2;
            // }
            // if ((i = 8) & isIpiece) {
            //     let dx = 0;
            //     let dy = -2;
            // }

            let canPlace = canPlaceWith(board, rot, rowPos, colPos, dy, dx); 
            if (canPlace) {
                do boundingBox.dispose();
                let boundingBox = rot;
                let colPos = colPos + dx;
                let rowPos = rowPos + dy;
                return true;
            }
            let i = i + 1;
        }

        do rot.dispose();
        return false;
    }

    method int hardDrop(Grid board){
        // move piece down while valid position
        var int dist;
        let dist = 0;
        while (canMove(board, 0, 1)){
            let rowPos = rowPos + 1;
            let dist = dist + 1;
        }

        return dist;
    }

    method void drawPieceInGrid(int horizontal_offset, int box_size, int space_size){
        var int x1, x2, y1, y2, c, r;
        let c = 1;
        let r = 1;
        
        let x1 = horizontal_offset + ((c-1) * (box_size + space_size));
        let y1 = (r-1) * (box_size + space_size);
        let x2 = x1 + (box_size);
        let y2 = y1 + (box_size);

        do Screen.drawRectangle(x1, y1, x2, y2);

        return;
    }

    method void dispose(){
        do boundingBox.dispose();
        do Memory.deAlloc(this);
        return;
    }

}