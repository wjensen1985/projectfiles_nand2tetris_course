/** Tetris Piece class */
class Piece {
    field int type;
    field int rowPos;
    field int colPos;
    field int rotationIndex;
    field Matrix boundingBox;
    field int boundingBoxSize;
    // need positions/points field to represent in grid space
    // pivot point?
    // types are I, O, T, S, Z, J, L -> map to ints?

    constructor Piece new(int initType, int x, int y){
        let type = initType;
        let rowPos = x;
        let colPos = y;
        let rotationIndex = 0;

        // let boundingBox = Matrix.new(4, 4, 0);
        // let boundingBoxSize = 4;
        // do boundingBox.set_point(1,2,1);
        // do boundingBox.set_point(2,2,1);
        // do boundingBox.set_point(3,2,1);
        // do boundingBox.set_point(4,2,1);
        // do boundingBox.set_all(1);

        // Types: 0: "I", 1: "O", 2: "Z", 3: "S", 4: "T", 5: "J", 6: "L"

        if ((initType = 0) | (initType = 1)){
            let boundingBox = Matrix.new(4, 4, 0);
            let boundingBoxSize = 4;
            do boundingBox.set_point(1,2,1);
            do boundingBox.set_point(2,2,1);
            do boundingBox.set_point(3,2,1);
            do boundingBox.set_point(4,2,1);
        }else{
            let boundingBox = Matrix.new(3, 3, 0);
            let boundingBoxSize = 3;
            do boundingBox.set_point(1,2,1);
            do boundingBox.set_point(2,2,1);
            do boundingBox.set_point(3,2,1);
        }

        return this;
    }

    method int get_bb_size(){
        return boundingBoxSize;
    }

    // method void placeInGrid(Grid grid){
    //     var Array piecePoints;
    //     // piece points from rotation point
    //     // --> array of points for piece
    //     // do Output.printChar(type);

    //     let piecePoints = calcGridCoords(rowPos, colPos, type);
        
    //     // for point in point list, set point in grid
    //     // list of poitns [r1, c1, value, r2, c2...], #points, value
    //     do grid.placePointsList(piecePoints, 4);

    //     return;
    // }

    method Array calcGridCoords(){
        var Array ret;
        var int i, bbRow, bbCol, tmp, retSize;
        let i = 0;
        let retSize = (boundingBoxSize * boundingBoxSize * 3);
        let ret = Array.new(retSize);
        // let ret = Array.new((4*3));


        let bbRow = 1;
        // do Output.printInt(bbRow);
        // do Output.printInt(boundingBoxSize);
        while (bbRow < (boundingBoxSize+1)) {
            let bbCol = 1;
            while (bbCol < (boundingBoxSize+1)){
                let tmp = boundingBox.get(bbRow, bbCol);
                // do Output.printInt(tmp);
                if (tmp = 1){
                    let ret[i] = rowPos + bbRow - 1 + 2;
                    let ret[i+1] = colPos + bbCol - 1;
                    let ret[i+2] = tmp;
                    let i = i + 3;
                }

                let bbCol = bbCol + 1;
            }
            let bbRow = bbRow + 1;
        }

        return ret;
    }

    method int getRow(){
        return rowPos;
    }

    method int getCol(){
        return colPos;
    }

    method void setRow(int newRowPos){
        let rowPos = newRowPos;
        return;
    }   

    method void setCol(int newColPos){
        let colPos = newColPos;
        return;
    }   

    method void tryMove(Grid board, int dc, int dr){
        // dc is change to column position (left/right)
        // dr is change to row position (up/down)
        
        var boolean canBeMoved;
        let canBeMoved = canMove(board, dc, dr);

        if (canBeMoved) {
            let rowPos = rowPos + dr;
            let colPos = colPos + dc;
        }

        return;
    }

    method boolean canMove(Grid board, int dc, int dr){
        var boolean ret;

        let ret = canPlaceWith(board, boundingBox, rowPos, colPos, dr, dc);
        
        return ret;
    }

    method Matrix rotateCW(Matrix src, int N){
        var Matrix dst;
        var int r, c, v;
        let dst = Matrix.new(N, N, 0);

        let r = 1;
        while (r < (N+1)) {
            let c = 1;
            while (c < (N+1)) {
                let v = src.get((N-c+1), r);
                if (v = 1){
                    do dst.set_point(r,c,1);
                }
                let c = c + 1;
            }
            let r = r + 1;
        }

        return dst;
    }

    method Matrix rotateCCW(Matrix src, int N){
        var Matrix dst;
        var int r, c, v;
        let dst = Matrix.new(N, N, 0);

        let r = 1;
        while (r < (N+1)) {
            let c = 1;
            while (c < (N+1)) {
                let v = src.get(c, (N-r+1));
                if (v = 1){
                    do dst.set_point(r,c,1);
                }
                let c = c + 1;
            }
            let r = r + 1;
        }

        return dst;
    }

    method boolean canPlaceWith(Grid board, Matrix shape, int baseRow, int baseCol, int dy, int dx){
        var int N, r, c, y, x, rows, cols, v;

        let N = boundingBoxSize;
        let rows = board.getRows();
        let cols = board.getCols();

        let r = 1;
        while (r < (N+1)){
            let c = 1;
            while (c < (N+1)){
                let v = shape.get(r, c);
                if (v = 1){
                    let y = baseRow + dy + r - 1;
                    let x = baseCol + dx + c - 1;
                
                    if ((x<1) | (x > cols) | (y<1) | (y > rows)){
                        // OOB
                        return false;
                    }

                    if (board.getPoint(y, x) = 1){
                        // point already occupied
                        return false;
                    }
                }
                let c = c + 1;
            }
            let r = r + 1;
        }

        return true;
    }

    method boolean tryRotateCW(Grid board){
        var Matrix rot;
        var int i, dx, dy;
        var boolean canPlace;
        
        let rot = rotateCW(boundingBox, boundingBoxSize);

        // wall kicks
        let i = 0;
        while (i < 4){
            if (i = 0) {
                let dx = 0;
                let dy = 0;
            }
            if (i = 1) {
                let dx = 1;
                let dy = 0;
            }
            if (i = 2) {
                let dx = -1;
                let dy = 0;
            }
            if (i = 3) {
                let dx = 0;
                let dy = -1;
            }

            let canPlace = canPlaceWith(board, rot, rowPos, colPos, dy, dx); 
            if (canPlace) {
                do boundingBox.dispose();
                let boundingBox = rot;
                let colPos = colPos + dx;
                let rowPos = rowPos + dy;
                return true;
            }
            let i = i + 1;
        }

        do rot.dispose();
        return false;
    }
   
    method boolean tryRotateCCW(Grid board){
        var Matrix rot;
        var int i, dx, dy;
        var boolean canPlace;
        
        let rot = rotateCCW(boundingBox, boundingBoxSize);

        // wall kicks
        let i = 0;
        while (i < 4){
            if (i = 0) {
                let dx = 0;
                let dy = 0;
            }
            if (i = 1) {
                let dx = 1;
                let dy = 0;
            }
            if (i = 2) {
                let dx = -1;
                let dy = 0;
            }
            if (i = 3) {
                let dx = 0;
                let dy = -1;
            }

            let canPlace = canPlaceWith(board, rot, rowPos, colPos, dy, dx); 
            if (canPlace) {
                do boundingBox.dispose();
                let boundingBox = rot;
                let colPos = colPos + dx;
                let rowPos = rowPos + dy;
                return true;
            }
            let i = i + 1;
        }

        do rot.dispose();
        return false;
    }

    method void drawPieceInGrid(int horizontal_offset, int box_size, int space_size){
        var int x1, x2, y1, y2, c, r;
        let c = 1;
        let r = 1;
        
        let x1 = horizontal_offset + ((c-1) * (box_size + space_size));
        let y1 = (r-1) * (box_size + space_size);
        let x2 = x1 + (box_size);
        let y2 = y1 + (box_size);

        do Screen.drawRectangle(x1, y1, x2, y2);

        return;
    }

    method void dispose(){
        do Memory.deAlloc(this);
        return;
    }

}