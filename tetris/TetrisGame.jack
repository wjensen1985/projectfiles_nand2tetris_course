/** Tetris Game class */
class TetrisGame { 
    field int score;
    field int level;
    field Grid grid;
    field Piece currentPiece;
    field int grid_start_px;
    field int prevFrameTime;
    field int time;
    field int updateTicks;
    field int prevKey;
    field int prevKeyTime;
    field int kbdTicks;

    field Array prevPieceCells; // len 12  (r, c, val) * 4
    field boolean firstFrame;
    field int gravityFrames;
    field int gravityCounter;

    field int dasFrames;
    field int arrFrames;
    field int lrHold;
    field int dasCounter;
    field int arrCounter;

    field int lockDelayFrames;
    field int lockCounter;
    field boolean onGround;
    field int softDropFrames;
    field int softDropCounter;

    field int nextType;

    field int lines;
    field int startLevel;
    field int nextLeveLineThreshold;
    field boolean gameOver;

    field PieceBag bag;

    constructor TetrisGame new(int initScore, int initLevel, int seed){
        let score = initScore;
        let level = initLevel;
        let grid = Grid.new(20, 10);
        let time = 0;
        let prevFrameTime = 0;
        let updateTicks = 200;
        let prevKey = 0;
        let prevKeyTime = 0;
        let kbdTicks = 500;


        let gravityFrames = 100;
        let gravityCounter = 0;
        let firstFrame = true;

        let dasFrames = 30;
        let arrFrames = 5;
        let lrHold = 0;
        let dasCounter = 0;
        let arrCounter = 0;

        let lockDelayFrames = 30;
        let lockCounter = 0;
        let onGround = false;

        let softDropFrames = 30;
        let softDropCounter = 0;

        let prevPieceCells = Array.new(12);

        let bag = PieceBag.new(seed);
        let nextType = bag.next();
        let currentPiece = Piece.new(nextType, 1, 4);
        let nextType = bag.next();

        let lines = 0;
        let startLevel = initLevel;
        let gameOver = false;

        let nextLeveLineThreshold = (startLevel * 10) + 10;
        let level = initLevel;
        do updateGravityForLevel();

        return this;
    }

    method void setup(){
        var int ref_px;

        let ref_px = grid.getHorizontalOffset();

        do grid.draw();
        do draw_statics(true, ref_px);

        return;
    }

    method int get_score(){
        return score;
    }

    method int get_level(){
        return level;
    }

    method boolean play(){
        var Array piece_grid_coords;
        var int timeDiff, i, j, found, cleared, frameCount;
        var boolean canMoveFlag2, arrFlag, canPlay, rotHoldFlag, sameCellFlag;
        
        let frameCount = 0;
        while (~(gameOver)){
            // read & handle input
            do handleKeyPress();
            if (gameOver){
                do piece_grid_coords.dispose();
                return false;
            }

            // apply gravity
            let gravityCounter = gravityCounter + 1;
            if (gravityCounter > (gravityFrames-1)){
                let canMoveFlag2 = currentPiece.canMove(grid, 0, 1);
                if (canMoveFlag2){
                    do currentPiece.tryMove(grid, 0, 1);
                    let onGround = false;
                    // let lockCounter = 0;
                } else {
                    if (~(onGround)){
                        let lockCounter = 0;
                    }
                    let onGround = true;
                }
                let gravityCounter = 0;
            }

            // locking
            if (onGround){
                let lockCounter = lockCounter + 1;
                if (lockCounter > (lockDelayFrames-1)){
                    // stamp to board
                    do lockCurrentPiece();
                    
                    // clear lines
                    let cleared = grid.clearFullLines();
                    if (cleared > 0){
                        do updateScoreAndLevel(cleared);
                    }
                    do drawHUD();
                    do grid.draw();

                    // spawn next active piece
                    do spawnNewPiece();

                    if (gameOver){
                        do piece_grid_coords.dispose();
                        return false;
                    }

                    // reset lock state
                    let lockCounter = 0;
                    let onGround = false;
                }
            } else {
                let lockCounter = 0;
            }

            // allocate this frames piece render info
            let piece_grid_coords = currentPiece.calcGridCoords();

            // render active piece (only changes vs. previous frame)
            if (firstFrame){
                do drawHUD();
                do grid.draw();
                let i = 0;
                while (i < 12){
                    if (piece_grid_coords[i+2] = 1){
                        do drawCell(piece_grid_coords[i], piece_grid_coords[i+1]);
                    }
                    let i = i + 3;
                }

                do seedPrevPieceCells(piece_grid_coords);
                let firstFrame = false;
            }

            // erase old loop
            let i = 0;
            while (i < 12){
                let found = 0;
                let j = 0;
                let sameCellFlag = false;
                while (j < 12){
                    let sameCellFlag = sameCell(prevPieceCells[i], prevPieceCells[i+1], piece_grid_coords[j], piece_grid_coords[j+1]);
                    if ( sameCellFlag ){
                        let found = 1;
                        let j = 12;
                    } else {
                    let j = j + 3;
                    }
                }

                if (found = 0){
                    do eraseCell(prevPieceCells[i], prevPieceCells[i+1]);
                }

                let i = i + 3;
            }

            // draw new loop
            let i = 0;
            while (i < 12){
                let found = 0;
                let j = 0;
                while (j < 12){
                    let sameCellFlag = sameCell(prevPieceCells[j], prevPieceCells[j+1], piece_grid_coords[i], piece_grid_coords[i+1]);
                    if ( sameCellFlag ){
                        let found = 1;
                        let j = 12;
                    } else {
                        let j = j + 3;
                    }
                }

                if (found = 0){
                    do drawCell(piece_grid_coords[i], piece_grid_coords[i+1]);
                }

                let i = i + 3;
            }
            
            // update prevPieceCells = piece_grid_coords (curent)
            let i = 0;
            while (i < 12){
                let prevPieceCells[i] = piece_grid_coords[i];
                let prevPieceCells[i+1] = piece_grid_coords[i+1];
                let prevPieceCells[i+2] = piece_grid_coords[i+2];
                let i = i + 3;
            }
            do piece_grid_coords.dispose();

            // update timers/counters - gravity, lock, input repeat, etc.
            if (lrHold = 0){
                let dasCounter = 0;
                let arrCounter = 0;
            } else {
                if (dasCounter < dasFrames){
                    let dasCounter = dasCounter + 1;
                } else{
                    let arrCounter = arrCounter + 1;
                    if (arrCounter > (arrFrames - 1)){
                        // repeat move right
                        if (lrHold = 1){
                            // do canMove = flag
                            let arrFlag = currentPiece.canMove(grid, 1, 0);
                            if (arrFlag){
                                do currentPiece.tryMove(grid, 1, 0);
                                do maybeResetlockAfterAction();
                            }
                        }

                        // repeat move left
                        if (lrHold = -1){
                            let arrFlag = currentPiece.canMove(grid, -1, 0);
                            if (arrFlag){
                                do currentPiece.tryMove(grid, -1, 0);
                                do maybeResetlockAfterAction();
                            }
                        }

                        // restart ARR window
                        let arrCounter = 0;
                    }
                }
            }

            if (~(onGround)){
                let lockCounter = 0;
            }

            if (gravityCounter < 0){
                let gravityCounter = 0;
            }
            if (gravityCounter > gravityFrames){
                let gravityCounter = 0;
            }

            if (dasCounter < 0){
                let dasCounter = 0;
            }
            if (arrCounter < 0){
                let arrCounter = 0;
            }

            let frameCount = frameCount + 1;
        }

        do piece_grid_coords.dispose();
        return false;
    }

    method void handleKeyPress(){
        var int curKey, dst;
        var boolean canMoveFlag;

        let curKey = Keyboard.keyPressed();

        // edge actions -> once per press - hard drop, rotates
        if ( (~(curKey = 0)) & (~(curKey = prevKey)) ) {
            // space => hard drop
            if (curKey = 32){
                let dst = currentPiece.hardDrop(grid);
                do addHardDropPoints(dst);
                let onGround = true;
                let lockCounter = lockDelayFrames;
            }

            // x or up arrow => rotateCW
            if ((curKey = 131) | (curKey = 120) | (curKey = 88)){
                if ( ~((currentPiece.getType()) = 1) ){
                    if (currentPiece.tryRotateCW(grid)){
                        do maybeResetlockAfterAction();
                    }
                    
                }
            }

            // z => rotateCCW
            if ((curKey = 122) | (curKey = 90)){
                if ( ~((currentPiece.getType()) = 1) ){
                    if (currentPiece.tryRotateCCW(grid)){
                        do maybeResetlockAfterAction();
                    }
                }
            }

            // esc => quite to menu
            if (curKey = 140){
                let gameOver = true;
            }

        }

        
        // lateral hold -- dealyed auto shift/auto repeat rate (DAS/ARR)
        // right arrow => move piece right 1
        if ((curKey = 132) | (curKey = 130)){
            if (curKey = 132){
                if (~(lrHold = 1)){
                    let lrHold = 1;
                    let dasCounter = 0;
                    let arrCounter = 0;
                    if(currentPiece.canMove(grid, 1, 0)){
                        do currentPiece.tryMove(grid, 1, 0);
                        do maybeResetlockAfterAction();
                    }
                }
            }
            // left arrow => move piece left 1
            if (curKey = 130){
                if (~(lrHold = -1)){
                    let lrHold = -1;
                    let dasCounter = 0;
                    let arrCounter = 0;
                    if (currentPiece.canMove(grid, -1, 0)){
                        do currentPiece.tryMove(grid, -1, 0);
                        do maybeResetlockAfterAction();
                    }                
                }
            }
        } else {
            let lrHold = 0;
        }

        if (curKey = 133){
            let softDropCounter = softDropCounter + 1;
            if (softDropCounter > (softDropFrames -1)){
                let canMoveFlag = currentPiece.canMove(grid, 0, 1);
                if (canMoveFlag){
                    do currentPiece.tryMove(grid, 0, 1);
                    let onGround = false;
                    let lockCounter = 0;
                    do addSoftDropPoint(1);
                } else {
                    let onGround = true;
                }
                let softDropCounter = 0;
            }
        } else {
            let softDropCounter = 0;
        }
        

        let prevKey = curKey;
        return;
    }

    method void draw_statics(boolean color, int ref_px){
        var int grid_start_px;
        var int grid_size_px; // includes extra 2px for rightmost border
        var int box_size, space_size;
        var int columns;
        var int rows;
        var int i, x1, x2, y1, y2;

        let box_size = 10;
        let space_size = 2;

        let rows = 21;
        let columns = 12;

        let grid_start_px = ref_px;
        let grid_size_px = 12 * 10;

        do Screen.setColor(color);
        // draw border columns on left and right of grid
        let i = 0;
        while (i < rows){
            // draw left border column:
            let x1 = ref_px - (box_size + space_size);
            let y1 = i * (box_size + space_size);
            let x2 = x1 + (box_size);
            let y2 = y1 + (box_size);

            do Screen.drawRectangle(x1, y1, x2, y2);

            // draw right border column:
            let x1 = ref_px + grid_size_px;
            let x2 = x1 + (box_size);

            do Screen.drawRectangle(x1, y1, x2, y2);

            let i = i + 1;
        }

        // draw border row on bottom of grid
        let i = 0;
        // y's are already set to correct row height/offset
        while (i < 10){
            let x1 = ref_px + ( i * (box_size + space_size));
            let x2 = x1 + (box_size);

            do Screen.drawRectangle(x1, y1, x2, y2);

            let i = i + 1;
        }

        do draw_smile(250);

        return;
    }

    method void draw_smile(int location) {
        var int memAddress;
        let memAddress = 16384 + location;
        do Memory.poke(memAddress + 0, 0);
        do Memory.poke(memAddress + 32, 0);
        do Memory.poke(memAddress + 64, 0);
        do Memory.poke(memAddress + 96, 1560);
        do Memory.poke(memAddress + 128, 1560);
        do Memory.poke(memAddress + 160, 0);
        do Memory.poke(memAddress + 192, 0);
        do Memory.poke(memAddress + 224, 16386);
        do Memory.poke(memAddress + 256, 8198);
        do Memory.poke(memAddress + 288, 12300);
        do Memory.poke(memAddress + 320, 6264);
        do Memory.poke(memAddress + 352, 16320);
        do Memory.poke(memAddress + 384, 27392);
        do Memory.poke(memAddress + 416, 20992);
        do Memory.poke(memAddress + 448, 19456);
        do Memory.poke(memAddress + 480, 28672);
        return;
    }

    method void seedPrevPieceCells(Array src){
        var int i;
        let i = 0;

        while (i < 12){
            let prevPieceCells[i] = src[i];
            let prevPieceCells[i+1] = src[i+1];
            let prevPieceCells[i+2] = src[i+2];
            let i = i + 3;
        }

        return;
    }

    method void eraseCell(int r, int c) {
        var int v;
        // draw background color just for this cell
        if ((c < 1) | (c > grid.getCols()) | (r < 1) | (r > grid.getRows())) {
            return;
        }
        let v = grid.getPoint(r, c);
        do grid.drawOverPoint(r, c, (v=1));
        return;
    }

    method void drawCell(int r, int c) {
        if ((c < 1) | (c > grid.getCols()) | (r < 1) | (r > grid.getRows())) {
            return;
        }
        do grid.drawOverPoint(r, c, true);
        return;
    }

    method void lockCurrentPiece() {
        var Array cells;
        let cells = currentPiece.calcGridCoords();
        do grid.stampCells(cells);
        do cells.dispose();
        return;
    }

    method boolean sameCell(int aR, int aC, int bR, int bC) {
        var boolean ret;
        let ret = ((aR = bR) & (aC = bC)); 
        return ret;
    }

    method boolean isGrounded() {
        return (~(currentPiece.canMove(grid, 0, 1)));
    }

    method void maybeResetlockAfterAction(){
        if (~(isGrounded())) {
            let onGround = false;
            let lockCounter = 0;
        }
        return;
    }

    method void spawnNewPiece() {
        var int t, spawnRow, spawnCol;
        // var Array tmp;
        
        // choose next piece type
        let t = nextType;
        // if (nextType = 6){
        //     let nextType = 0;
        // } else {
        //     let nextType = nextType + 1;
        // }



        // spawn coords - center-ish
        let spawnRow = 1;
        let spawnCol = 4;

        do currentPiece.dispose();
        let currentPiece = Piece.new(t, spawnRow, spawnCol);

        let nextType = bag.next();

        if (~(currentPiece.canMove(grid, 0, 0))) {
            // game over
            let gameOver = true;
            return;
        }

        // reset movement/lock timers
        let onGround = false;
        let lockCounter = 0;
        let lrHold = 0;
        let dasCounter = 0;
        let arrCounter = 0;

        // re-seed prevPieceCells
        // let tmp = currentPiece.calcGridCoords();
        // do seedPrevPieceCells(tmp);
        // do tmp.dispose();

        // let firstFrame = true;

        return;
    }

    method void updateScoreAndLevel(int cleared){
        var int base, add, wasBelow, wasAbove;

        if (cleared = 0){
            return;
        }

        if (cleared = 1){
            let base = 40;
        }
        if (cleared = 2){
            let base = 100;
        }
        if (cleared = 3){
            let base = 300;
        }
        if (cleared = 4){
            let base = 1200;
        }

        let add = (base * (level + 1));
        let score = score + add;

        let lines = lines + cleared;

        if (lines > (nextLeveLineThreshold -1)){
            let level = level + 1;
            let nextLeveLineThreshold = nextLeveLineThreshold + 10;
            do updateGravityForLevel();
        }

        return;
    }

    method void addSoftDropPoint(int cells){
        let score = score + cells;
        return;
    }

    method void updateGravityForLevel(){
        var int f;

        if (level = 0){ let f = (48 * 2); }
        if (level = 1){ let f = (43 * 2); }
        if (level = 2){ let f = (38 * 2); }
        if (level = 3){ let f = (33 * 2); }
        if (level = 4){ let f = (28 * 2); }
        if (level = 5){ let f = (23 * 2); }
        if (level = 6){ let f = (18 * 2); }
        if (level = 7){ let f = (13 * 2); }
        if (level = 8){ let f = (8 * 2);  }
        if (level = 9){ let f = (6 * 2);  }
        if ((level > 9) & (level < 13)){ let f = (5 * 2); }
        if ((level > 12) & (level < 16)){ let f = (4 * 2); }
        if ((level > 15) & (level < 19)){ let f = (3 * 2); }
        if ((level > 18) & (level < 29)){ let f = (2 * 2); }
        if (level > 28){ let f = (1 * 2); }

        let gravityFrames = f;
        if (softDropFrames < gravityFrames){
            let softDropFrames = gravityFrames;
        }

        return;
    }

    method void addHardDropPoints(int cells){
        let score = score + (2 * cells);
        return;
    }

    method void drawHUD(){
        do Screen.setColor(false);
        do Screen.drawRectangle(2, 0, 150, 12);  // wipe a strip
        do Screen.setColor(true);

        do Output.moveCursor(0,0);
        do Output.printString("SCORE:");
        do Output.printInt(score);

        do Output.moveCursor(1,0);
        do Output.printString("LEVEL:");
        do Output.printInt(level);

        do Output.moveCursor(2,0);
        do Output.printString("LINES:");
        do Output.printInt(lines);

        return;
    }

    method int getScore(){
        return score;
    }

    method void dispose(){
        do prevPieceCells.dispose();
        do grid.dispose();
        do currentPiece.dispose();
        do bag.dispose();
        do Memory.deAlloc(this);
        return;
    }
}