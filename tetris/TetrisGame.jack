/** Tetris Game class */
class TetrisGame { 
    field int score;
    field int level;
    field Grid grid;
    field Piece currentPiece;
    field int grid_start_px;
    field int prevFrameTime;
    field int time;
    field int frameRate;


    /* 
    other fields:
     - current piece
     - next piece
     - last piece (can't have)
     - piece bag
     - array of pieces -> pop as use?
     - grid
    */

    constructor TetrisGame new(int initScore, int initLevel){
        let score = initScore;
        let level = initLevel;
        let grid = Grid.new(20, 10);
        let currentPiece = Piece.new(1, 4, 4);
        let time = 0;
        let prevFrameTime = 0;
        let frameRate = 30;

        return this;
    }

    method void setup(){
        var int ref_px;

        let ref_px = grid.getHorizontalOffset();

        do grid.draw();
        do draw_statics(true, ref_px);

        return;
    }

    method int get_score(){
        return score;
    }

    method int get_level(){
        return level;
    }

    method void draw(int time){
        var Array pieceGridPts;
        var int i, lenPts, timeDiff;

        // draw 'locked' points if Frame is > frameRate past prevFrame
        let timeDiff = time - prevFrameTime;
        if (timeDiff > frameRate){
            do grid.draw();
            let prevFrameTime = time;
        }

        // draw in the current Pieces 'active' points
        let pieceGridPts = currentPiece.calcGridCoords();
        let lenPts = currentPiece.get_bb_size();
        // (r, c, val)
        let lenPts = (lenPts * 3);

        let i = 0;
        while (i < lenPts){
            if (pieceGridPts[i+2] = 1){
                // draw point in grid
                do grid.drawOverPoint(pieceGridPts[i], pieceGridPts[i+1], true);

            }

            let i = i + 3;
        } 
        
        do pieceGridPts.dispose();
        return;
    }

    method boolean play(){
        var Array piece_grid_coords;
        var int curKey;

        while(time < 1000) {
            
            // check current piece can be locked/is in_bounds:

            // update screen/draw current game state:
            do draw(prevFrameTime);


            // Get User input:
            // detect key press
            let curKey = Keyboard.keyPressed();
            // do Output.printChar(curKey);
            if ((curKey = 65) | (curKey = 97)){
                do Output.printChar(curKey);
            }

            let time = time + 1;
        }


        return false;
    }

    method void draw_statics(boolean color, int ref_px){
        var int grid_start_px;
        var int grid_size_px; // includes extra 2px for rightmost border
        var int box_size, space_size;
        var int columns;
        var int rows;
        var int i, x1, x2, y1, y2;

        let box_size = 10;
        let space_size = 2;

        let rows = 21;
        let columns = 12;

        let grid_start_px = ref_px;
        let grid_size_px = 12 * 10;

        do Screen.setColor(color);
        // draw border columns on left and right of grid
        let i = 0;
        while (i < rows){
            // draw left border column:
            let x1 = ref_px - (box_size + space_size);
            let y1 = i * (box_size + space_size);
            let x2 = x1 + (box_size);
            let y2 = y1 + (box_size);

            do Screen.drawRectangle(x1, y1, x2, y2);

            // draw right border column:
            let x1 = ref_px + grid_size_px;
            let x2 = x1 + (box_size);

            do Screen.drawRectangle(x1, y1, x2, y2);

            let i = i + 1;
        }

        // draw border row on bottom of grid
        let i = 0;
        // y's are already set to correct row height/offset
        while (i < 10){
            let x1 = ref_px + ( i * (box_size + space_size));
            let x2 = x1 + (box_size);

            do Screen.drawRectangle(x1, y1, x2, y2);

            let i = i + 1;
        }


        return;
    }

    method void dispose(){
        do Memory.deAlloc(this);
        return;
    }
}