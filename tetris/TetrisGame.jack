/** Tetris Game class */
class TetrisGame { 
    field int score;
    field int level;
    field Grid grid;
    field Piece currentPiece;
    field int grid_start_px;
    field int prevFrameTime;
    field int time;
    field int updateTicks;
    field int curKey;
    field int prevKey;
    field int prevKeyTime;
    field int kbdTicks;


    /* 
    other fields:
     - current piece
     - next piece
     - last piece (can't have)
     - piece bag
     - array of pieces -> pop as use?
     - grid
    */

    constructor TetrisGame new(int initScore, int initLevel){
        let score = initScore;
        let level = initLevel;
        let grid = Grid.new(20, 10);
        let currentPiece = Piece.new(1, 4, 4);
        let time = 0;
        let prevFrameTime = 0;
        let updateTicks = 200;
        let curKey = 0;
        let prevKey = 0;
        let prevKeyTime = 0;
        let kbdTicks = 500;

        return this;
    }

    method void setup(){
        var int ref_px;

        let ref_px = grid.getHorizontalOffset();

        do grid.draw();
        do draw_statics(true, ref_px);

        return;
    }

    method int get_score(){
        return score;
    }

    method int get_level(){
        return level;
    }

    method void draw(int timeDiff){
        var Array pieceGridPts;
        var int i, lenPts;

        // draw 'locked' points if Frame is > updateTicks past prevFrame
        // let timeDiff = time - prevFrameTime;
        // if (timeDiff > (updateTicks-2)){
        //     do grid.draw();
        // }

        if (timeDiff = 0){
            do grid.draw();        
            // draw in the current Pieces 'active' points
            let pieceGridPts = currentPiece.calcGridCoords();
            let lenPts = currentPiece.get_bb_size();
            // (r, c, val)
            let lenPts = (lenPts * 3);

            let i = 0;
            while (i < lenPts){
                if (pieceGridPts[i+2] = 1){
                    // draw point in grid
                    do grid.drawOverPoint(pieceGridPts[i], pieceGridPts[i+1], true);
                } 
                // else {
                //     if( (grid.getPoint(pieceGridPts[i], pieceGridPts[i+1])) = 1){
                //         do grid.drawOverPoint(pieceGridPts[i], pieceGridPts[i+1], true);
                //     }
                // }

                let i = i + 3;
            } 
            do pieceGridPts.dispose();
        }


        
        return;
    }

    method boolean play(){
        var Array piece_grid_coords;
        var int timeDiff;

        let time = 0;
        let prevFrameTime = 0;
        let prevKeyTime = 0;
        let timeDiff = 0;

        // time < 20000
        while(true) {
            
            // update time step:
            if (timeDiff > updateTicks){
                let prevFrameTime = time;
            }
            let timeDiff = time - prevFrameTime;
            
            // check current piece can be locked/is in_bounds:


            // update screen/draw current game state:
            do draw(timeDiff);


            // Get User input:
            let curKey = Keyboard.keyPressed();

            if (~(curKey = 0) ) {
                if ( ~(curKey = prevKey) ) { 
                    // is new key pressed -> handle and save time/key value
                    
                    // handle key press functionality
                    do handleKeyPress(curKey);
                    // do Output.printChar(curKey);
                    
                    // update state:
                    let prevKeyTime = time;
                    let prevKey = curKey;
                } else{
                    // is previously pressed key
                    if ((time - prevKeyTime) > kbdTicks) {
                        // re-handle key press
                        do handleKeyPress(curKey);
                        // do Output.printChar(curKey);

                        // update state:
                        let prevKeyTime = time;
                        let prevKey = curKey;
                    }
                }
            }

            let time = time + 1;
        }

        do piece_grid_coords.dispose();
        return false;
    }

    method void handleKeyPress(int curKey){
        if (curKey = 133){
            // down arrow => move piece down 1 (soft drop)
            do currentPiece.tryMove(grid, 0, 1);
        }
        if (curKey = 132){
            // right arrow => move piece right 1
            do currentPiece.tryMove(grid, 1, 0);
        }
        if (curKey = 130){
            // left arrow => move piece left 1
            do currentPiece.tryMove(grid, -1, 0);
        }

        // if (curKey = 32){
        //     // space => hard drop

        // }

        if ((curKey = 131) | ( curKey = 114) | (curKey = 120)){
            // r or up arrow => rotateCW
            do currentPiece.tryRotateCW(grid);
        }

        if ((curKey = 122)){
            // z => rotateCCW
            do currentPiece.tryRotateCCW(grid);
        }

        return;
    }

    method void draw_statics(boolean color, int ref_px){
        var int grid_start_px;
        var int grid_size_px; // includes extra 2px for rightmost border
        var int box_size, space_size;
        var int columns;
        var int rows;
        var int i, x1, x2, y1, y2;

        let box_size = 10;
        let space_size = 2;

        let rows = 21;
        let columns = 12;

        let grid_start_px = ref_px;
        let grid_size_px = 12 * 10;

        do Screen.setColor(color);
        // draw border columns on left and right of grid
        let i = 0;
        while (i < rows){
            // draw left border column:
            let x1 = ref_px - (box_size + space_size);
            let y1 = i * (box_size + space_size);
            let x2 = x1 + (box_size);
            let y2 = y1 + (box_size);

            do Screen.drawRectangle(x1, y1, x2, y2);

            // draw right border column:
            let x1 = ref_px + grid_size_px;
            let x2 = x1 + (box_size);

            do Screen.drawRectangle(x1, y1, x2, y2);

            let i = i + 1;
        }

        // draw border row on bottom of grid
        let i = 0;
        // y's are already set to correct row height/offset
        while (i < 10){
            let x1 = ref_px + ( i * (box_size + space_size));
            let x2 = x1 + (box_size);

            do Screen.drawRectangle(x1, y1, x2, y2);

            let i = i + 1;
        }


        return;
    }

    method void dispose(){
        do Memory.deAlloc(this);
        return;
    }
}