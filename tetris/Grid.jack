/** Grid class for grid of Game tiles. */
class Grid {
    field int rows;
    field int cols;
    field int hiddenRows; // how many of the rows (top down) are hidden
    field Matrix points_grid;
    field int box_size;
    field int space_size;
    field int horizontal_offset;
    /* 
    other fields:
     - list of tiles cols x (rows + hiddenRows)
     -- need method/function to help draw these tiles/board to screen
     - isOverflow?  tells whether grid is overflowing?

    methods:
     - draw
     - canClearRow
     -- check what row(s) can be cleared
     - clearRow
     -- clears a given row
    */
    // checks what row(s) in the grid can be cleared
/*
    method int canClearRows(){

        return;
    }
*/

    // draws current grid state on to the screen
    method void draw(){
        // 20 + 1 rows, 10 + 2 cols, space (2px), size (10px)
        var int x1, x2, y1, y2, r, c, p;

        let r = 1;
        while (r < (rows+1)){
            let c = 1;
            while (c < (cols+1)){
                // check if grid[r][c] is filled, if so, draw black, else draw white
                let p = points_grid.get((r+hiddenRows), c);
                // do Output.printInt(p);
                if (p = 0){
                    do Screen.setColor(false);
                    // do Screen.setColor(true);
                }
                else{
                    // do Screen.setColor(false);
                    // do Output.printInt(r);
                    // do Output.printInt(c);
                    do Screen.setColor(true);
                }

                let x1 = horizontal_offset + ((c-1) * (box_size + space_size));
                let y1 = (r-1) * (box_size + space_size);
                let x2 = x1 + (box_size);
                let y2 = y1 + (box_size);

                do Screen.drawRectangle(x1, y1, x2, y2);

                let c = c + 1;
            }
            let r = r + 1;
        }

        return;
    }

    method void drawOverPoint(int r, int c, boolean colr) {
        var int x1, x2, y1, y2;

        do Screen.setColor(colr);

        let x1 = horizontal_offset + ((c-1) * (box_size + space_size));
        let y1 = (r-1) * (box_size + space_size);
        let x2 = x1 + (box_size);
        let y2 = y1 + (box_size);

        do Screen.drawRectangle(x1, y1, x2, y2);

        return;
    }


    // clears a given row -> set to all 0
    method void clearRow(int row){
        // testing set r, c
        // do points_grid.set_point(1+hiddenRows,1,1);
        // do points_grid.set_point(1+hiddenRows,10,1);
        // do points_grid.set_point(6+hiddenRows,5,1);
        // do points_grid.set_point(2+hiddenRows,1,1);
        // do points_grid.set_point(19+hiddenRows,10,1);
        // do points_grid.set_point(20+hiddenRows,10,1);
        // do points_grid.set_point(20+hiddenRows,1,1);
        // do points_grid.set_point(20+hiddenRows,0,1);
        // do points_grid.set_point(22+hiddenRows,0,1);

        // testing set_row
        do points_grid.set_row(row+hiddenRows, 0);

        return;
    }

    // sets a given row -> set to all 1
    method void fillRow(int row){
        // testing set_row
        do points_grid.set_row(row+hiddenRows, 1);

        return;
    }

    method void testingBB_border(int bbX, int bbY, int bbSize){
        let bbX = bbX+2;
        do points_grid.set_point((bbX-1), (bbY-1), 1);
        do points_grid.set_point((bbX-1), (bbY+0), 1);
        do points_grid.set_point((bbX-1), (bbY+1), 1);
        do points_grid.set_point((bbX-1), (bbY+2), 1);
        do points_grid.set_point((bbX-1), (bbY+3), 1);

        if (bbSize = 4){
            do points_grid.set_point((bbX-1), (bbY+4), 1);
            do points_grid.set_point((bbX+bbSize), (bbY+4), 1);
            do points_grid.set_point((bbX+3), bbY-1, 1);
            do points_grid.set_point((bbX+3), bbY+bbSize, 1);

        }

        do points_grid.set_point((bbX+bbSize), (bbY-1), 1);
        do points_grid.set_point((bbX+bbSize), (bbY+0), 1);
        do points_grid.set_point((bbX+bbSize), (bbY+1), 1);
        do points_grid.set_point((bbX+bbSize), (bbY+2), 1);
        do points_grid.set_point((bbX+bbSize), (bbY+3), 1);

        do points_grid.set_point((bbX), bbY-1, 1);
        do points_grid.set_point((bbX+1), bbY-1, 1);
        do points_grid.set_point((bbX+2), bbY-1, 1);
    
        do points_grid.set_point((bbX), bbY+bbSize, 1);
        do points_grid.set_point((bbX+1), bbY+bbSize, 1);
        do points_grid.set_point((bbX+2), bbY+bbSize, 1);
    
        return;
    }

    // sets all points in grid -> set to 0
    method void clearGrid(){
        // testing set_all
        do points_grid.set_all(0);
        
        return;
    }
    
    
    // sets all points in grid -> set to 1
    method void fillGrid(){
        // testing set_all
        do points_grid.set_all(1);
        
        return;
    }

    // points [r1, c1, val1, r2, c2, val2.... ]
    method void placePointsList(Array points, int numPoints){
        var int i, pts, r, c, val;
        let i = 0;
        let pts = 0;

        while (pts < numPoints){
            let r = points[i];
            let c = points[i+1];
            let val = points[i+2];

            do points_grid.set_point(r, c, val);

            let pts = pts + 1;
            let i = i + 3;
        }

        return;
    }

    method int getPoint(int row, int col){
        return points_grid.get((row + hiddenRows), col);
    }

    method int getBoxSize(){
        return box_size;
    }
    method int getSpaceSize(){
        return space_size;
    }
    method int getHorizontalOffset(){
        return horizontal_offset;
    }

    method int getRows(){
        return rows;
    }
    method int getCols(){
        return cols;
    }

    constructor Grid new(int initRows, int initCols){
        let rows = initRows;
        let cols = initCols;
        let hiddenRows = 2;
        let points_grid = Matrix.new(rows + hiddenRows, cols, 0);

        let box_size = 10;
        let space_size = 2;

        let horizontal_offset = (512 / 2) - (((box_size * cols) + (space_size * (cols - 1) ) ) / 2);

        return this;
    }

    method void dispose(){
        do Memory.deAlloc(this);
        return;
    }

}